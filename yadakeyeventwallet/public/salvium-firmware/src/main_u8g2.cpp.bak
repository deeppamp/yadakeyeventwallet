#include <Arduino.h>
#include <Wire.h>
#include <U8g2lib.h>
#include <qrcode.h>
#include <ArduinoJson.h>

// I2C display pins (CONFIRMED WORKING)
#define OLED_SDA 21
#define OLED_SCL 22
#define OLED_ADDR 0x3C

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

// Create multiple display objects to test
U8G2_SH1106_128X64_NONAME_F_HW_I2C display1(U8G2_R0, U8X8_PIN_NONE, OLED_SCL, OLED_SDA);
U8G2_SH1106_128X64_NONAME_F_SW_I2C display2(U8G2_R0, OLED_SCL, OLED_SDA, U8X8_PIN_NONE);
U8G2_SSD1306_128X64_NONAME_F_HW_I2C display3(U8G2_R0, U8X8_PIN_NONE, OLED_SCL, OLED_SDA);
U8G2_SSD1306_128X64_NONAME_F_SW_I2C display4(U8G2_R0, OLED_SCL, OLED_SDA, U8X8_PIN_NONE);

// Pointer to the working display
U8G2* display = nullptr;
int workingConfig = 0;

// Button pins
#define BTN_UP    32
#define BTN_DOWN  33
#define BTN_SELECT 25

// Wallet state
enum Screen {
  SCREEN_SPLASH,
  SCREEN_BLOCKCHAIN_SELECT,
  SCREEN_WALLET_INFO,
  SCREEN_RECEIVE,
  SCREEN_QR_CODE
};

Screen currentScreen = SCREEN_SPLASH;
String currentBlockchain = "YadaCoin";
String walletAddress = "";
float balance = 0.0;
unsigned long lastButtonPress = 0;
const unsigned long debounceDelay = 200;

void showSplashScreen() {
  display->clearBuffer();
  display->setFont(u8g2_font_ncenB14_tr);
  display->drawStr(10, 25, "Salvium");
  display->setFont(u8g2_font_6x10_tr);
  display->drawStr(15, 45, "Hardware Wallet");
  display->drawStr(20, 58, "v1.0 - Ready!");
  display->sendBuffer();
}

void drawBlockchainSelect() {
  display->setFont(u8g2_font_6x10_tr);
  display->drawStr(0, 10, "Select Blockchain:");
  
  if(currentBlockchain == "YadaCoin") {
    display->setDrawColor(1);
    display->drawBox(0, 20, 128, 12);
    display->setDrawColor(0);
  }
  display->drawStr(5, 30, "> YadaCoin");
  display->setDrawColor(1);
  
  if(currentBlockchain == "Salvium") {
    display->setDrawColor(1);
    display->drawBox(0, 32, 128, 12);
    display->setDrawColor(0);
  }
  display->drawStr(5, 42, "> Salvium");
  display->setDrawColor(1);
  
  display->setFont(u8g2_font_5x8_tr);
  display->drawStr(0, 55, "UP/DOWN to select");
  display->drawStr(0, 63, "SELECT to confirm");
}

void drawWalletInfo() {
  display->setFont(u8g2_font_6x10_tr);
  display->drawStr(0, 10, currentBlockchain.c_str());
  display->drawLine(0, 12, 128, 12);
  
  display->drawStr(0, 25, "Balance:");
  display->setFont(u8g2_font_ncenB10_tr);
  char balanceStr[20];
  snprintf(balanceStr, sizeof(balanceStr), "%.4f", balance);
  display->drawStr(0, 40, balanceStr);
  
  display->setFont(u8g2_font_5x8_tr);
  display->drawStr(0, 55, "SELECT: Receive");
  display->drawStr(0, 63, "UP: Sync wallet");
}

void drawReceiveScreen() {
  display->setFont(u8g2_font_6x10_tr);
  display->drawStr(0, 10, "Receive Address:");
  display->drawLine(0, 12, 128, 12);
  
  display->setFont(u8g2_font_5x8_tr);
  if(walletAddress.length() > 0) {
    String line1 = walletAddress.substring(0, 25);
    String line2 = walletAddress.substring(25, 50);
    String line3 = walletAddress.substring(50);
    display->drawStr(0, 25, line1.c_str());
    display->drawStr(0, 35, line2.c_str());
    display->drawStr(0, 45, line3.c_str());
  } else {
    display->drawStr(0, 30, "No address");
    display->drawStr(0, 40, "Connect to wallet");
  }
  
  display->drawStr(0, 63, "SELECT: Show QR");
}

void drawQRCode() {
  if(walletAddress.length() == 0) {
    display->setFont(u8g2_font_6x10_tr);
    display->drawStr(10, 32, "No address set");
    return;
  }
  
  QRCode qrcode;
  uint8_t qrcodeData[qrcode_getBufferSize(3)];
  qrcode_initText(&qrcode, qrcodeData, 3, ECC_LOW, walletAddress.c_str());
  
  int scale = 2;
  int offsetX = (SCREEN_WIDTH - (qrcode.size * scale)) / 2;
  int offsetY = (SCREEN_HEIGHT - (qrcode.size * scale)) / 2;
  
  for (uint8_t y = 0; y < qrcode.size; y++) {
    for (uint8_t x = 0; x < qrcode.size; x++) {
      if (qrcode_getModule(&qrcode, x, y)) {
        display->drawBox(offsetX + (x * scale), offsetY + (y * scale), scale, scale);
      }
    }
  }
}

void drawScreen() {
  display->clearBuffer();
  switch(currentScreen) {
    case SCREEN_BLOCKCHAIN_SELECT: drawBlockchainSelect(); break;
    case SCREEN_WALLET_INFO: drawWalletInfo(); break;
    case SCREEN_RECEIVE: drawReceiveScreen(); break;
    case SCREEN_QR_CODE: drawQRCode(); break;
    default: break;
  }
  display->sendBuffer();
}

void handleButtons() {
  unsigned long now = millis();
  if(now - lastButtonPress < debounceDelay) return;
  
  bool upPressed = digitalRead(BTN_UP) == LOW;
  bool downPressed = digitalRead(BTN_DOWN) == LOW;
  bool selectPressed = digitalRead(BTN_SELECT) == LOW;
  
  if(!upPressed && !downPressed && !selectPressed) return;
  lastButtonPress = now;
  
  if(currentScreen == SCREEN_BLOCKCHAIN_SELECT) {
    if(upPressed || downPressed) {
      currentBlockchain = (currentBlockchain == "YadaCoin") ? "Salvium" : "YadaCoin";
      Serial.printf("Blockchain: %s\n", currentBlockchain.c_str());
      drawScreen();
    }
    else if(selectPressed) {
      currentScreen = SCREEN_WALLET_INFO;
      Serial.printf("Wallet: %s\n", currentBlockchain.c_str());
      drawScreen();
    }
  }
  else if(currentScreen == SCREEN_WALLET_INFO) {
    if(selectPressed) { currentScreen = SCREEN_RECEIVE; drawScreen(); }
    else if(upPressed) { Serial.println("Sync wallet"); }
  }
  else if(currentScreen == SCREEN_RECEIVE) {
    if(selectPressed) { currentScreen = SCREEN_QR_CODE; drawScreen(); }
    else if(downPressed) { currentScreen = SCREEN_WALLET_INFO; drawScreen(); }
  }
  else if(currentScreen == SCREEN_QR_CODE) {
    if(selectPressed || downPressed) { currentScreen = SCREEN_RECEIVE; drawScreen(); }
  }
}

void handleSerialCommands() {
  if(!Serial.available()) return;
  
  String command = Serial.readStringUntil('\n');
  command.trim();
  
  StaticJsonDocument<512> doc;
  DeserializationError error = deserializeJson(doc, command);
  if(error) return;
  
  const char* cmd = doc["cmd"];
  if(strcmp(cmd, "setAddress") == 0) {
    walletAddress = doc["address"].as<String>();
    Serial.printf("Address: %s\n", walletAddress.c_str());
  }
  else if(strcmp(cmd, "setBalance") == 0) {
    balance = doc["balance"];
    Serial.printf("Balance: %.4f\n", balance);
    drawScreen();
  }
  else if(strcmp(cmd, "setBlockchain") == 0) {
    currentBlockchain = doc["blockchain"].as<String>();
    currentScreen = SCREEN_WALLET_INFO;
    drawScreen();
  }
}

bool testDisplayConfig(U8G2* testDisplay, const char* name) {
  Serial.printf("[TEST] Trying %s...\n", name);
  
  testDisplay->begin();
  testDisplay->setPowerSave(0);  // Turn display ON
  testDisplay->setContrast(255); // Max contrast
  testDisplay->clearBuffer();
  
  // Try to fill entire screen first
  testDisplay->setDrawColor(1);
  testDisplay->drawBox(0, 0, 128, 64);  // Draw white box
  testDisplay->sendBuffer();
  delay(500);
  
  // Now draw text
  testDisplay->clearBuffer();
  testDisplay->setFont(u8g2_font_ncenB14_tr);
  testDisplay->drawStr(0, 30, "TEST");
  testDisplay->setFont(u8g2_font_6x10_tr);
  testDisplay->drawStr(0, 50, name);
  testDisplay->sendBuffer();
  
  delay(2000);
  
  // If we get here without crashing, this config works
  Serial.printf("[OK] %s works!\n", name);
  return true;
}

void setup() {
  Serial.begin(115200);
  delay(500);
  
  pinMode(BTN_UP, INPUT_PULLUP);
  pinMode(BTN_DOWN, INPUT_PULLUP);
  pinMode(BTN_SELECT, INPUT_PULLUP);
  
  Serial.println("\n========================================");
  Serial.println("  AUTO-DETECTING DISPLAY TYPE");
  Serial.println("  Testing 4 configurations...");
  Serial.println("========================================");
  
  // Test each configuration
  if (testDisplayConfig(&display1, "SH1106 HW I2C")) {
    display = &display1;
    workingConfig = 1;
  }
  else if (testDisplayConfig(&display2, "SH1106 SW I2C")) {
    display = &display2;
    workingConfig = 2;
  }
  else if (testDisplayConfig(&display3, "SSD1306 HW I2C")) {
    display = &display3;
    workingConfig = 3;
  }
  else if (testDisplayConfig(&display4, "SSD1306 SW I2C")) {
    display = &display4;
    workingConfig = 4;
  }
  
  if (display == nullptr) {
    Serial.println("[ERROR] No working display config found!");
    while(1) { delay(1000); }
  }
  
  // CRITICAL: Set maximum contrast for SH1106 (many boards default to 0 contrast!)
  Serial.println("[FIX] Setting display power ON and MAXIMUM contrast...");
  display->setPowerSave(0);     // Make SURE display is powered on
  display->setContrast(255);    // Maximum brightness/contrast
  display->setFlipMode(0);      // Try normal orientation first
  
  Serial.printf("\n[SUCCESS] Using config #%d\n", workingConfig);
  Serial.println("========================================");
  
  // Draw full WHITE SCREEN test first
  Serial.println("[TEST] Drawing FULL WHITE screen test...");
  display->clearBuffer();
  display->setDrawColor(1);
  display->drawBox(0, 0, 128, 64);  // Fill entire screen white
  display->sendBuffer();
  delay(2000);  // Hold for 2 seconds - you should see a bright white rectangle
  
  // Draw test pattern
  Serial.println("[TEST] Drawing test pattern...");
  display->clearBuffer();
  display->setFont(u8g2_font_ncenB14_tr);
  display->drawStr(10, 30, "FOUND!");
  display->setFont(u8g2_font_6x10_tr);
  char configText[32];
  snprintf(configText, sizeof(configText), "Config #%d", workingConfig);
  display->drawStr(0, 50, configText);
  display->sendBuffer();
  
  Serial.println("[TEST] Test pattern sent");
  delay(3000);
  
  Serial.println("[TEST] Drawing splash screen...");
  showSplashScreen();
  delay(2000);
  
  Serial.println("[TEST] Drawing main screen...");
  currentScreen = SCREEN_BLOCKCHAIN_SELECT;
  drawScreen();
  
  Serial.println("[OK] Hardware wallet initialized");
  Serial.println("Buttons: UP=32, DOWN=33, SELECT=25");
}

void loop() {
  handleButtons();
  handleSerialCommands();
  delay(10);
}
